# Autogenerated wrapper script for pocl_jll for x86_64-w64-mingw32-cxx11
export libpocl, poclcc

using OpenCL_jll
using OpenCL_Headers_jll
using Hwloc_jll
using Zstd_jll
using SPIRV_LLVM_Translator_jll
using SPIRV_Tools_jll
using Clang_unified_jll
using LLD_unified_jll
JLLWrappers.@generate_wrapper_header("pocl")
JLLWrappers.@declare_library_product(libpocl, "pocl.dll")
JLLWrappers.@declare_executable_product(poclcc)
function __init__()
    JLLWrappers.@generate_init_header(OpenCL_jll, OpenCL_Headers_jll, Hwloc_jll, Zstd_jll, SPIRV_LLVM_Translator_jll, SPIRV_Tools_jll, Clang_unified_jll, LLD_unified_jll)
    JLLWrappers.@init_library_product(
        libpocl,
        "bin\\pocl.dll",
        RTLD_LAZY | RTLD_DEEPBIND,
    )

    JLLWrappers.@init_executable_product(
        poclcc,
        "bin\\poclcc.exe",
    )

    JLLWrappers.@generate_init_footer()
    # Register this driver with OpenCL_jll
if OpenCL_jll.is_available()
    push!(OpenCL_jll.drivers, libpocl)

    # XXX: Clang_jll does not have a functional clang binary on macOS,
    #      as it's configured without a default sdkroot (see #9221)
    if Sys.isapple()
        ENV["SDKROOT"] = "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
    end
end
# expose JLL binaries to the library
# XXX: Scratch.jl is unusably slow with JLLWrapper-emitted @compiler_options
#bindir = @get_scratch!("bin")
bindir = abspath(first(Base.DEPOT_PATH), "scratchspaces", string(Base.PkgId(@__MODULE__).uuid), "bin")
mkpath(bindir)
function generate_wrapper_script(name, path, LIBPATH, PATH)
    if Sys.iswindows()
        LIBPATH_env = "PATH"
        LIBPATH_default = ""
        pathsep = ';'
    elseif Sys.isapple()
        LIBPATH_env = "DYLD_FALLBACK_LIBRARY_PATH"
        LIBPATH_default = "~/lib:/usr/local/lib:/lib:/usr/lib"
        pathsep = ':'
    else
        LIBPATH_env = "LD_LIBRARY_PATH"
        LIBPATH_default = ""
        pathsep = ':'
    end

    # XXX: cache, but invalidate when deps change

    # write to temporary script
    temp_script, io = mktemp(bindir; cleanup=false)
    script = if Sys.isunix()
        println(io, "#!/bin/bash")

        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        LIBPATH_value = if !isempty(LIBPATH_base)
            string(LIBPATH, pathsep, LIBPATH_base)
        else
            LIBPATH
        end
        println(io, "export $LIBPATH_env=\"$LIBPATH_value\"")

        if LIBPATH_env != "PATH"
            PATH_base = get(ENV, "PATH", "")
            PATH_value = if !isempty(PATH_base)
                string(PATH, pathsep, ENV["PATH"])
            else
                PATH
            end
            println(io, "export PATH=\"$PATH_value\"")
        end

        println(io, "exec \"$path\" \"\$@\"")
        close(io)
        chmod(temp_script, 0o755)
        joinpath(bindir, name)
    elseif Sys.iswindows()
        println(io, "@echo off")

        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        LIBPATH_value = if !isempty(LIBPATH_base)
            string(LIBPATH, pathsep, LIBPATH_base)
        else
            LIBPATH
        end
        println(io, "set \"$LIBPATH_env=$LIBPATH_value\"")

        println(io, "call \"$path\" %*")

        joinpath(bindir, name * ".bat")
    else
        error("Unsupported platform")
    end
    close(io)

    # atomically move to the final location
    @static if VERSION >= v"1.12.0-DEV.1023"
        mv(temp_script, script; force=true)
    else
        Base.rename(temp_script, script, force=true)
    end

    return script
end
ENV["POCL_PATH_SPIRV_LINK"] =
    generate_wrapper_script("spirv_link", SPIRV_Tools_jll.spirv_link_path,
                            SPIRV_Tools_jll.LIBPATH[], SPIRV_Tools_jll.PATH[])
ENV["POCL_PATH_CLANG"] =
    generate_wrapper_script("clang", Clang_unified_jll.clang_path,
                            Clang_unified_jll.LIBPATH[], Clang_unified_jll.PATH[])
ENV["POCL_PATH_LLVM_SPIRV"] =
    generate_wrapper_script("llvm-spirv",
                            SPIRV_LLVM_Translator_jll.llvm_spirv_path,
                            SPIRV_LLVM_Translator_jll.LIBPATH[],
                            SPIRV_LLVM_Translator_jll.PATH[])
ld_path = if Sys.islinux()
        LLD_unified_jll.ld_lld_path
    elseif Sys.isapple()
        LLD_unified_jll.ld64_lld_path
    elseif Sys.iswindows()
        # PoCL doesn't use MSVC-style linker arguments, so still use the GNU ld wrapper.
        LLD_unified_jll.ld_lld_path
    else
        error("Unsupported platform")
    end
ld_wrapper = generate_wrapper_script("lld", ld_path,
                                     LLD_unified_jll.LIBPATH[],
                                     LLD_unified_jll.PATH[])

# expose libc to Clang, even if the system doesn't have development symlinks
libdir = abspath(first(Base.DEPOT_PATH), "scratchspaces", string(Base.PkgId(@__MODULE__).uuid), "lib")
mkpath(libdir)
for lib in Libdl.dllist()
    startswith(basename(lib), "libc.so.6") || continue
    link = joinpath(libdir, "libc.so")
    try
        symlink(lib, link)
    catch
        # can't safely check first, because multiple processes may be running
        islink(link) || rethrow()
    end
end
if Sys.iswindows()
    # BUG: using native (backwards) slashes breaks Clang's --ld-path
    ld_wrapper = replace(ld_wrapper, '\\' => '/')
end
ENV["POCL_ARGS_CLANG"] = join([
        "-fuse-ld=lld", "--ld-path=$ld_wrapper",
        "-L", joinpath(artifact_dir, "share", "lib"),
        "-L", libdir
    ], ";")

end  # __init__()
